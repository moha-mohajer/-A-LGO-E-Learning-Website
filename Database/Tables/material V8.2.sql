-- phpMyAdmin SQL Dump
-- version 4.0.4.2
-- http://www.phpmyadmin.net
--
-- Host: localhost
-- Generation Time: Apr 03, 2017 at 04:43 PM
-- Server version: 5.6.13
-- PHP Version: 5.4.17

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- Database: `co1801assignment`
--

-- --------------------------------------------------------

--
-- Table structure for table `material`
--

CREATE TABLE IF NOT EXISTS `material` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `Subject` varchar(100) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `Title` varchar(100) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `Material` text CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `MoreInfo` varchar(100) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `Activiti` varchar(100) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  `ActivitiSrc` varchar(100) CHARACTER SET latin1 COLLATE latin1_general_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=8 ;

--
-- Dumping data for table `material`
--

INSERT INTO `material` (`id`, `Subject`, `Title`, `Material`, `MoreInfo`, `Activiti`, `ActivitiSrc`) VALUES
(1, 'Representing Algorithms', 'Basics of Algorithms', 'An algorithm is a set of steps for solving a particular problem. To be an algorithm, a set of rules must be unambiguous(obvious) and have a clear stopping point. Algorithms can be expressed in any programming language.<br>To make a computer do anything, you have to write a computer program. To write a computer &apos;program, you must tell the computer, step by step, exactly what you want it to do. The computer then &quot;executes&quot; the program, following each step mechanically, to accomplish the end goal.<br>\r\nWhen you are telling the computer what to do, you also get to choose how it&apos;s going to do it. That&apos;s where computer algorithms come in. The algorithm is the basic technique used to get the job done.', 'https://www.khanacademy.org/computing/computer-science/algorithms#intro-to-algorithms \r\n\r\n', 'Video', 'https://www.youtube.com/embed/LCrMJuEBkQY'),
(2, 'Searching Algorithms', 'Explanation of Searching Algorithms\r\n', 'A search algorithm is the step-by-step procedure used to locate specific data among a collection of data. It is considered a fundamental procedure in computing. In computer science, when searching for data, the difference between a fast application and a slower one often lies in the use of the proper search algorithm.<br>All search algorithms make use of a search key in order to proceed with the procedure. Search algorithms are expected to return a success or a failure status. Different search algorithms are available, and the performance and efficiency of the same depend on the data and on the manner in which they are used. We are going to talk about two of the basics Search Algorithms, Linear Search and Binary Search.\r\n', '', 'Video', 'https://www.youtube.com/embed/J5RZOU6vK4Q'),
(3, 'Searching Algorithms', 'Explanation of Linear Search\r\n', 'A Linear Search is the basic and simplest search algorithm, as the name implies is a searching algorithm which obtains its result by traversing a list of data items sequentially (one after the other). It will start at the beginning of a list, and mosey on through until the desired element is found, or in some cases is not found. The aspect of Linear Search which makes it inefficient in this respect is that if the element is not in the list it will have to go through the entire list anyway. This can be quite cumbersome for lists of very large magnitude, keep this in mind as you contemplate how and where to implement this algorithm. Of course, conversely the best case for this would be that the desired element is the first element of the list.<br>Linear Search Steps:<br>Step 1 - Does the item match the value I&apos;m looking for?<br>Step 2 - If it does match return, you&apos;ve found your item!<br>Step 3 - If it does not match advance and repeat the process.<br>Step 4 - Reached the end of the list and still no value found? Then return that you have not found the item!<br>Advantages of Linear Search<br>Very easy algorithm to understand and implement. Due to the simple implementation of this algorithm, computing teachers choose to teach Linear Search as the first algorithm for the students to use.<br>Can work with both sorted and unsorted data. A big advantage of Linear Search is the ability to search through sorted and unsorted data since it searches each element one by one.<br>Disadvantages of Linear Search<br>The linear search is inefficient - If the data being searched contains 20,000 elements, the algorithm must look at all 20,000 elements to find a value that might be the last element. In an average case, an item is just as likely to be found near the beginning of the data as near the end. Typically, for data of N items, the linear search will locate an item in N/2 attempts. If a data has 100,000 elements, the linear search will make a comparison with 50,000 of them in a typical case. This is a huge disadvantage for Linear Search because it can cause huge performance decrease and at the same time it consumes too much memory to complete the search.\r\n', '', 'Animation', 'https://www.tutorialspoint.com/data_structures_algorithms/images/linear_search.gif'),
(4, 'Searching Algorithms', 'Explanation of Binary Search', 'Binary Search can be only applied on sorted data. In binary search, we first compare the desired element with the element in the middle position of the data. If the desired element is matched with the middle element of our data, then the desired element is found. If the desired element is smaller than the middle element, then it must lie in the lower half of the data and if it&apos;s greater than the element then it must lie in the upper half of the data. We repeat this procedure on the lower (or upper) half of the data until the desired element is found, or in some cases not found.<br>Binary Search Steps:<br>Step 1 - Does the middle item match the value I&apos;m looking for?<br>Step 2 - If it does match return, you&apos;ve found your item!<br>Step 3 - If it does not match, check if the value I&apos;m looking for is smaller or bigger than the middle item.<br>Step 4 - If the value I&apos;m looking for is smaller than the middle item then eliminates every element that&apos;s in the right (bigger) of the middle element and find the middle of the elements at the left (smaller) of the middle element. If the value I&apos;m looking for is bigger than the middle item, then eliminate every element that&apos;s in the left (smaller) of the middle element and find the middle of the elements at the right (bigger) of the middle element.<br>Step 5 - Repeat the process until you find the value I&apos;m looking. If the value is not found, return that you have not found the item!<br>Advantages of Binary Search<br>Fast and efficient - The data that needs to be searched halves with each step. For example, it is possible to search through 1024 values and find the one you want within 10 steps, every time.<br>Disadvantages of Binary Search<br>Can only work if the data is in sorted form. Since it starts its search from the middle element of a list, Binary Search needs the data inside the list to be sorted so as to halve the list accordingly. If the data inside the list is not sorted, then the results are unpredictable. There is 34% chance to find the desired element in an unsorted list of 10 elements and 6% in an unsorted list of 100 elements.<br>Comparison between Binary and Linear Search<br>Both algorithms have their advantages and limitations, Binary Search needs a sorted list to complete Its search but Linear Search can work with both sorted and unsorted lists. If a sorted list has 1024 elements inside and the element we are looking for is the last element in this list, Linear Search would have to check all the elements (1024 steps) one by one to find the desired element, from the other hand Binary Search would only take 10 steps to find that element. To sum up, Binary Search is a fast and efficient algorithm but needs a sorted list to work, Linear Search is an inefficient algorithm when is dealing with large scale data but can work with both sorted and unsorted data.', 'https://www.khanacademy.org/computing/computer-science/algorithms#binary-search', 'Video', 'https://www.youtube.com/embed/5xlIPT1FRcA'),
(5, 'Sorting Algorithms', 'Explanation of sorting Algorithms', 'A sorting algorithm is an algorithm that puts elements of a list in a certain order (ascending or descending) according to our needs. The most-used orders are numerical (1,2,3,4 etc.) and lexicographical (a,b,c,d etc.) order. Sorting is important in computer science for the same reason it is important in everyday life, imagine that a neighborhood has 200 houses that are randomly named from 1 to 200, if you are searching for the house with the number 90 you will be wasting a lot of time until you find it unless you are lucky, but what if the houses were sorted in numeric order, wouldn&apos;t be way easier and less time consuming to find the desired house?<br>Comparison between Merge and Bubble Sort<br>As stated before, Merge sort is an advanced sorting algorithm, meaning that the implementation of this algorithm is more difficult than others (in this case bubble sort). Merge sort is a great sorting algorithm to use but with a serious limitation, it needs a lot of memory to work. Even though the need of memory is big, the speed of sorting is huge thus a balance between memory and speed is developed. In the other hand, bubble sort is an easy algorithm to implement, with low need of memory but with very limited speed, as the size of the list increases so the sorting time adds.\r\n', '', 'Game', 'http://www.advanced-ict.info/interactive/algorithms.html'),
(6, 'Sorting Algorithms', 'Explanation of Bubble Sort ', 'Bubble sort is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted<br>The Algorithm<br>Bubble Sort Steps:<br>Assuming that we have a list of 6 unsorted elements (3,2,6,5,1,4) and we want to sort the in ascending order<br>Step 1 - We compare the first two elements of the list (3 and 2), swap the smallest of the two elements at the left position\r\n(2,3,6,5,1,4)<br>Step 2 - We compare the next two elements of the list (3 and 6), swap the smallest of the two elements at the left position. Since 3 is smaller than 6 we don&apos;t swap.<br>(2,3,6,5,1,4)<br>Step 3 - We compare the next two elements of the list (6 and 5), swap the smallest of the two elements at the left position.<br>(2,3,5,6,1,4)<br>Step 4 - We compare the next two elements of the list (6 and 1), swap the smallest of the two elements at the left position. \r\n(2,3,5,1,6,4)<br>Step 5 - We compare the next two elements of the list (6 and 4), swap the smallest of the two elements at the left position. \r\n(2,3,5,1,4,6)<br>Step 6 - We reached the end of our list, but that doesn	&apos;t mean we are finished, as you can see the list is not sorted yet. We repeat the above steps until the list is completely sorted.\r\n', '', 'Animation', 'https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif'),
(7, 'Sorting Algorithms', 'Explanation of Merge Sort', 'Merge sort is one of the most used sorting algorithms. Is considered an advanced sorting algorithm since the way it works is a bit complicate. The way that merge sort works is by dividing a given list of data into smaller lists of data in order to sort them. In merge sort the list of data is firstly divided into two halves, and then those two halves are divided again until we get lists that each one contains one element inside. Then, those one element lists are merged together into bigger lists and at the same time they are compared and sorted with their closer element until a new sorted list is created, this might sound confusing and hard to understand but in reality, the algorithm is just doing three simple things divide, sort, merge<br>Merge Sort Steps:<br>Assuming that we have a list of 8 unsorted elements (2,8,6,5,1,4,7,3) and we want to sort the in ascending order<br>Step 1 - Divide the list in two halves (each one contains 4 elements)<br>(2,8,6,5) | (1,4,7,3)<br>Step 2 - Divide each new list in half (each one contains 2 elements)<br>(2,8) | (6,5) | (1,4) | (7,3)<br>Step 3 - Divide each new list in half (each one contains 1 element)<br>(2) | (8) | (6) (5) | (1) (4) | (7) | (3)<br>Step 4 - Our goal of creating a new list for each element has been achieved, now we compare every two lists between them and we create a new list with the smallest element at the beginning of each list<br>(2,8) | (5,6) | (1,4) | (3,7)<br>Step 5 - We repeat the previous step with our new lists<br>(2,5,6,8) | (1,3,4,7)<br>Step 6 - Last step, we repeat again the previous step in order to get then new sorted list<br>(1,2,3,4,5,6,7,8)<br>Here is an image of how merge sort works.', 'https://www.khanacademy.org/computing/computer-science/algorithms#merge-sort', 'Video', 'https://www.youtube.com/embed/EeQ8pwjQxTM');

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
